/*

백준 온라인 저지
출처: https://www.acmicpc.net/problem/15552
문제: 본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다.
C++을 사용하고 있고 cin/cout을 사용하고자 한다면, cin.tie(NULL)과 sync_with_stdio(false)를 둘 다 적용해주고, endl 대신 개행문자(\n)를 쓰자.
단, 이렇게 하면 더 이상 C의 입출력 방식을 사용하면 안 된다.
입력: 첫 줄에 테스트케이스의 개수 T가 주어진다. T는 최대 1,000,000이다. 다음 T줄에는 각각 두 정수 A와 B가 주어진다. A와 B는 1 이상, 1,000 이하이다.
출력: 각 테스트케이스마다 A+B를 한 줄에 하나씩 순서대로 출력한다.
예제 입력: 
5
1 1
12 34
5 500
40 60
1000 1000
예제 출력:
2
46
505
100
2000

*/

#include<iostream>
using namespace std;
int main(){
    long int T, a, b;
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);
    cin >> T;
    for (int i = 0; i < T; i++){
        cin >> a >> b;
        cout << a + b << "\n";
    }
    return 0;
}

/*

1. C++과 C 표준 스트림의 동기화 해제
C++은 C++과 C의 표준 스트림이 동기화되어 있다. 따라서 C++에서 C의 형태로 입출력 받아도 원하는 결과를 얻을 수 있다. 
C++에서 동기화를 끊게 되면 C++ 표준 스트림이 독립적으로 입출력 버퍼링을 할 수 있다. (동기화 되어 있을 때에 비해 속도 빨라짐)
ios_base::sync_with_stdio(false)를 하게 되면 C++에서 동기화를 끊을 수 있다. (기본 형태는 ios_base::sync_with_stdio(true))

2. 입력, 출력 연결 끊기
C++에서 입력 요청이 들어오면, 출력 버퍼에 내용이 있는 경우 버퍼를 flush해서 출력을 하게 된다. 
하지만 cin.tie(NULL)로 입력과 출력의 연결을 끊어주면 입력이 들어올 때 출력 버퍼를 자동으로 비워주지 않게 된다. 

3. endl과 '\n'의 차이
endl을 사용하면 단순히 개행만 하는 것이 아니라 출력 버퍼를 비우는 역할을 한다. 
출력 버퍼를 비우는 작업에 시간이 소요되기 때문에 endl이 아니라 '\n'을 사용하면 한꺼번에 출력버퍼를 비워 시간을 절약할 수 있다.

*/